#ifndef CORE_SYREC_COMPONENTS_CUSTOM_BASE_VISITOR_HPP
#define CORE_SYREC_COMPONENTS_CUSTOM_BASE_VISITOR_HPP
#pragma once

#include "TSyrecParserBaseVisitor.h"

#include <core/syrec/parser/components/generic_visitor_result.hpp>
#include <core/syrec/parser/utils/custom_error_mesages.hpp>
#include <core/syrec/parser/utils/parser_messages_container.hpp>

#include <fmt/core.h>
#include <optional>

namespace syrecParser {
    class CustomBaseVisitor: protected TSyrecParserBaseVisitor {
    public:
        CustomBaseVisitor(std::shared_ptr<ParserMessagesContainer> sharedGeneratedMessageContainerInstance):
            sharedGeneratedMessageContainerInstance(std::move(sharedGeneratedMessageContainerInstance)) {}

    protected:
        std::shared_ptr<ParserMessagesContainer> sharedGeneratedMessageContainerInstance;

        template<SemanticError semanticError, typename... T>
        void recordSemanticError(Message::Position messagePosition, T&&... args) {
            if (!sharedGeneratedMessageContainerInstance)
                return;

            static_assert(!getFormatForSemanticErrorMessage<semanticError>().empty(), "No format for message of semantic error found!");
            static_assert(!identifierForSemanticErrore.empty(), "No identifiers for semantic error found!");

            constexpr std::string_view identifierForSemanticError = getIdentifierForSemanticError<semanticError>();
            // TODO: How should runtime errors be handled?
            sharedGeneratedMessageContainerInstance->recordMessage(std::make_unique(Message::Type::Error, std::string(identifierForSemanticError), messagePosition, fmt::format(FMT_STRING(getFormatForSemanticErrorMessage<semanticError>()), std::forward<T>(args)...), {}));
        }

        void recordCustomError(Message::Position messagePosition, const std::string& errorMessage) {
            sharedGeneratedMessageContainerInstance->recordMessage(std::make_unique<Message>(Message::Type::Error, "UNKNOWN", messagePosition, errorMessage));
        }

        /// Process the tokens of a non-terminal symbol of an ANTLR grammar and return a single entity of the IR representing the non-terminal symbol.
        /// @tparam ExpectedResultType Define the expected type of the result generated by the processing of the non-terminal symbol.
        /// @param ruleContext The ANTLR context holding the syntactic information for the given non-terminal symbol
        /// @return A wrapper class holding a result of the expected type (provided as the template argument).
        template<typename ExpectedResultType>
        [[nodiscard]] std::optional<std::shared_ptr<ExpectedResultType>> visitNonTerminalSymbolWithSingleResult(antlr4::ParserRuleContext* ruleContext) {
            // Utilizing the dynamic dispatch mechanism to process the non-terminal symbol thus assuming that the visitor will implement an adequate visit overload for the given ParserRuleContext of the non-terminal symbol
            // TODO: Should the use provide the callback that shall be used to the processing of the non-terminal instead of relying on the dynamic dispatch mechanism (that only throws an exception during runtime if no matching callback was found) with the latter detecting errors during compile time
            if (const GenericVisitorResult<ExpectedResultType>* genericProductionResult = std::any_cast<GenericVisitorResult<ExpectedResultType>*>(visit(ruleContext)); genericProductionResult)
                return genericProductionResult->getData();
            return std::nullopt;
        }

        /// Process the tokens of a non-terminal symbol of an ANTLR grammar and return a collection storing various instances of an entity of the IR representing non-terminal symbol.
        /// @tparam ExpectedResultType Define the expected type of the result generated by the processing of the non-terminal symbol.
        /// @param ruleContext The ANTLR context holding the syntactic information for the given non-terminal symbol
        /// @return A wrapper class holding a result of the expected type (provided as the template argument).
        template<typename ExpectedResultType>
        [[nodiscard]] std::optional<std::vector<std::shared_ptr<ExpectedResultType>>> visitNonTerminalSymbolWithManyResults(antlr4::ParserRuleContext* ruleContext) {
            // Utilizing the dynamic dispatch mechanism to process the non-terminal symbol thus assuming that the visitor will implement an adequate visit overload for the given ParserRuleContext of the non-terminal symbol
            // TODO: Should the use provide the callback that shall be used to the processing of the non-terminal instead of relying on the dynamic dispatch mechanism (that only throws an exception during runtime if no matching callback was found) with the latter detecting errors during compile time
            const std::vector<GenericVisitorResult<ExpectedResultType>>* genericProductionResult = std::any_cast<std::vector<GenericVisitorResult<ExpectedResultType>>*>(visit(ruleContext));
            if (!genericProductionResult)
                return std::nullopt;

            std::vector<std::shared_ptr<ExpectedResultType>>             aggregateContainer(genericProductionResult->size(), nullptr);

            bool                                                         aggregationSuccessful = true;
            for (std::size_t i = 0; aggregationSuccessful && i < genericProductionResult->size(); ++i) {
                aggregateContainer[i] = genericProductionResult->at(i).getData();
                aggregationSuccessful &= genericProductionResult->at(i).getData() != nullptr;
            }
            return aggregationSuccessful ? std::make_optional(aggregateContainer) : std::nullopt;
        }
    };
}

#endif